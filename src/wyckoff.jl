# ---------------------------------------------------------------------------------------- #
# STRUCTS

# Wyckoff positions
struct WyckPos{D} <: AbstractVec{D}
    mult   :: Int
    letter :: Char
    qv     :: RVec{D} # associated with a single representative
end
qvec(wp::WyckPos)     = wp.qv
free(wp::WyckPos)     = free(qvec(wp))
constant(wp::WyckPos) = constant(qvec(wp))

multiplicity(wp::WyckPos) = wp.mult
label(wp::WyckPos) = string(multiplicity(wp), wp.letter)

function show(io::IO, ::MIME"text/plain", wp::WyckPos)
    print(io, wp.mult, wp.letter, ": ")
    show(io, MIME"text/plain"(), qvec(wp))
end

# Site symmetry groups
struct SiteGroup{D} <: AbstractGroup{D}
    num::Int
    wp::WyckPos{D}
    operations::Vector{SymOperation{D}}
    cosets::Vector{SymOperation{D}}
end
function summary(io::IO, g::SiteGroup)
    print(io, typeof(g), " #", num(g), " at ", label(g.wp), " = ")
    show(io, MIME"text/plain"(), qvec(g.wp))
    print(io, " with ", length(g), " operations")
end

# ---------------------------------------------------------------------------------------- #
# CONSTRUCTORS/GETTERS FOR WYCKPOS

"""
$(SIGNATURES)

Return the Wyckoff positions of space group `sgnum` in dimension `D` as a 
`Vector{WyckPos{D}`.

The positions are given in the conventional basis setting, following the conventions of the
Bilbao Crystallographic Server (from where the underlying data is obtained [1]).

[1] Aroyo, et. al. Zeitschrift fuer Kristallographie (2006), 221, 1, 15-27.
"""
function wyckpos(sgnum::Integer, ::Val{D}) where D
    strarr = open((@__DIR__)*"/../data/wyckpos/$(D)d/"*string(sgnum)*".csv") do io
        DelimitedFiles.readdlm(io, '|', String, '\n')
    end
    mults   = parse.(Int, @view strarr[:,1])
    letters = only.(@view strarr[:,2])
    qvs     = RVec{D}.(@view strarr[:,3])

    return WyckPos{D}.(mults, letters, qvs)
end
wyckpos(sgnum::Integer, D) = wyckpos(sgnum, Val(D))

# ---------------------------------------------------------------------------------------- #
# METHODS

"""
    ∘(op::SymOperation, qv::RVec) --> RVec

Return the composition of `op` ``= \\{W|w\\}`` with a real-space vector `qv`.

The operation is taken to act directly, i.e. returns ``\\{W|w\\}```qv` ``= W```qv```+w``
rather than ``\\{W|w\\}^{-1}```qv` ``= W^{-1}```qv` ``- W^{-1}w``, which can instead be
obtained from `inv(op)∘qv`.
"""
function (∘)(op::SymOperation{D}, qv::RVec{D}) where D
    cnst, free = parts(qv)
    W, w       = unpack(op)

    cnst′ = W*cnst + w
    free′ = W*free

    return RVec{D}(cnst′, free′)
end
(∘)(op::SymOperation{D}, wp::WyckPos{D}) where D = WyckPos{D}(multiplicity(wp), wp.letter,
                                                              op∘qvec(wp))

function SiteGroup(sg::SpaceGroup{D}, wp::WyckPos{D}) where D
    Nsg  = order(sg)
    Ncoset = multiplicity(wp)
    Nsite, check = divrem(Nsg, Ncoset)
    if check != 0
        throw(DomainError((Ncoset, Nsg), "Wyckoff multiplicity must divide space group order"))
    end

    siteops = Vector{SymOperation{D}}(undef, Nsite)
    cosets  = Vector{SymOperation{D}}(undef, Ncoset)
    qv      = qvec(wp)
    
    # both cosets and site symmetry group contains the identity operation; add them
    id = SymOperation{D}(SMatrix{D,D,Float64,D*D}(I), zero(SVector{D,Float64}))
    siteops[1] = cosets[1] = id
    isite, icoset = 1,1
    for op in sg
        icoset == Ncoset && isite == Nsite && break # stop if all necessary representatives found
        op == id && continue # already added identity outside loop; avoid adding twice

        W, w = unpack(op) # rotation and translation
        qv′  = op∘qv
        Δ    = qv′ - qv
        Δcnst, Δfree = parts(Δ)

        # Check whether difference between qv and qv′ is a lattice vector: if so, `op` is 
        # isomorphic to a site symmetry operation; if not, to a coset operation.
        # We check this in the original lattice basis, i.e. do not force  conversion to a
        # primitive basis. This is consistent with e.g. Bilbao and makes good sense.
        # The caller is of course free to do this themselves (via their choice of basis for
        # the specified `sg` and `wp`).
        if ( # tolerance'd equiv. of `all(isinteger, Δcnst) && all(iszero, Δfree))`
             all(x->isapprox(x, round(x), atol=DEFAULT_ATOL), Δcnst) && 
             all(x->abs(x)≤(DEFAULT_ATOL), Δfree) )             # ⇒ site symmetry operation

            w′ = w - Δcnst
            siteops[isite+=1] = SymOperation{D}(W, w′)

        else                                                    # ⇒ coset operation
            icoset == Ncoset && continue # we only need Ncoset representatives in total

            # make all `WyckPos`s in orbit generated by coset operations have q′ᵢ∈[0,1)
            w′ = w - constant(qv′) + reduce_translation_to_unitrange(constant(qv′))
            cosets[icoset+=1] = SymOperation{D}(W, w′)

            # TODO: For certain Wyckoff positions in space groups 151:154 (8 in total), the
            #       above calculation of w′ lead to very small (~1e-16) negative values for
            #       the new representatives generated from these coset operations, i.e.
            #       `orbit(g, wp)` can contain Wyckoff positions with negative coordinates,
            #       differing from zero by ~1e-16.
        end        
    end
    return SiteGroup{D}(num(sg), wp, siteops, cosets)
end
function SiteGroup(sgnum::Integer, wp::WyckPos{D}) where D
    sg = spacegroup(sgnum, Val(D))
    return SiteGroup(sg, wp)
end

# `MulTable`s of `SiteGroup`s should be calculated with modτ = false always
function MultTable(g::SiteGroup; verbose::Bool=false)
    MultTable(operations(g); modτ=false, verbose=verbose)
end

function orbit(g::SiteGroup{D}, wp::WyckPos{D}) where D
    qv′s = g.cosets .∘ Ref(qvec(wp))
    return WyckPos{D}.(multiplicity(wp), wp.letter, qv′s)
end