# probably ought to do this with show/repr and a custom mime type to be idiomatic
function lattice2mpb(flat::AbstractFourierLattice)
    orbits = getorbits(flat); coefs = getcoefs(flat)
    Nterms = sum(length, coefs)
    orbits_mpb_vec = Vector{String}(undef, Nterms)
    coefs_mpb_vec  = Vector{String}(undef, Nterms)
    idx = 1
    for (G, c) in zip(Iterators.flatten(orbits), Iterators.flatten(coefs))
        orbits_mpb_vec[idx] = "(vector3"*mapfoldl(x-> " "*string(x), *, G)*")"
        c_re = real(c); c_im = imag(c);
        coefs_mpb_vec[idx]  = string(real(c))*signaschar(c_im)*string(abs(c_im))*"i"
        idx += 1
    end
    orbits_mpb = "(list"*mapfoldl(x->" "*x, *, orbits_mpb_vec)*")"
    coefs_mpb  = "(list"*mapfoldl(x->" "*x, *, coefs_mpb_vec)*")"
    return orbits_mpb, coefs_mpb
end

function filling2isoval(flat::AbstractFourierLattice{D}, filling::Real=0.5, nsamples::Int64=51) where D
    step = 1.0/nsamples
    samples = range(-0.5, 0.5-step, length=nsamples)
    if D == 2
        itr = (real(calcfourier((x,y), flat)) for x in samples for y in samples)
    elseif D == 3
        itr = (real(calcfourier((x,y,z), flat)) for x in samples for y in samples for z in samples)
    end
    return quantile(itr, filling)
end

function mpb_calcname!(io, dim, sgnum, id, res, runtype="all")
    write(io, "dim",  string(dim),
              "-sg",  string(sgnum), 
              "-",    string(id),
              "-res", string(res))
    if runtype != "all"
        write(io, "-", runtype)
    end
    return nothing
end
function mpb_calcname(dim, sgnum, id, res, runtype="all")
    io = IOBuffer()
    mpb_calcname!(io, dim, sgnum, id, res, runtype)
    return String(take!(io))
end


function _vec2list(io::IO, f, vs::AbstractVector)
    write(io, "(list")
    for v in vs
        print(io, ' ', f(v))
    end
    write(io, ')')
    return io
end
_vec2list(io::IO, vs::AbstractVector) = _vec2list(io, identity, vs)
_vec2list(f, vs::AbstractArray) = String(take!(_vec2list(IOBuffer(), f, vs)))
_vec2list(vs::AbstractArray) = _vec2list(identity, vs)

function _vec2vector3(v::AbstractVector)
    length(v) > 3 && throw(DomainError(v, "A vector3 must be either one-, two-, or three-dimensional"))

    return "(vector3 "*join(v, ' ')*')'
end

function _mat2matrix3x3(m)
    size(m) ≠ (3,3) && throw(DomainError(m, "A matrix3x3 must be of size (3,3)"))
    # TODO: We should probably allow feeding in 2D and 1D matrices as well.
    io = IOBuffer()
    write(io, "(matrix3x3")
    for i in 1:3
        write(io, ' ', _vec2vector3(@view m[:,i]))
    end
    write(io, ')')
    return String(take!(io))
end

""" 
    prepare_mpbcalc!(...)

Formats a set of parameters that uniquely specify an MPB calculation, given a 
space group number `sgnum`, a Fourier lattice `flat`, a DirectBasis `Rs`, a filling
fraction `filling` for `flat`, interior and exterior (above, below the contour)
permittivities `εin` and `εout`, as well as a list of k-vectors `kvecs`, an 
identifying tag `id` (to label the calculation for book-keeping purposes), a 
resolution for the MPB calculation `res`, and a selection of calculation type
`runtype` ("all", "te", or "tm"). The results are written to requested IO `io`.

Our preferred choice is to write these parameters to a bash file, with a name
generated by the `mpb_calcname(...)` method.

The options are expected to be fed to the `fourier-lattice.ctl` file, e.g. through
a bash script of the following kind:
```sh
    IFS=\$'\\n'; # stop command-substitutions from word-splitting at space

    PATH_TO_MPB_EXECUTABLE \\
        (cat \${calcname}.sh)
        ctl/fourier-lattice.ctl 2>&1 | tee logs/\${calcname}.log
        
    unset IFS; # restore usual command-substitution word-splitting practice
```
on gbar, `PATH_TO_MPB_EXECUTABLE` is `~/postdoc/mpb-transform-dev/1.8-dev/bin/mpb`.
Locally, in `mpb-ctl` we have a file `run-fourier-lattice.sh` which performs the 
above, with `calcname` specified as an input parameter (assumed to be a subfolder
`/input/`).
"""
function prepare_mpbcalc!(io::IO, sgnum::Integer, flat::AbstractFourierLattice{D},
                          Rs::DirectBasis{D},
                          filling::Real=0.5, εin::Real=10.0, εout::Real=1.0,
                          runtype::String="all";
                          # kwargs
                          id=1,
                          res::Integer=32,
                          kvecs::Union{Nothing, AbstractVector{<:Vector{Number}}}=nothing,
                          lgs::Union{Nothing, AbstractVector{LittleGroup{D}}}=nothing) where D

    # --- work to actually call mpb ---
    calcname = mpb_calcname(D, sgnum, id, res, runtype)
    rvecs = _vec2list(_vec2vector3, Rs)
    uc_gvecs, uc_coefs = lattice2mpb(flat)
    uc_level = filling2isoval(flat, filling)

    # prepare and write all runtype, structural, and identifying inputs
    print(io, # run-type ("all", "te", or "tm")
              "run-type", "=",  "\"", runtype,  "\"",  "\n",
              # dimension, space group, resolution, and prefix name
              "dim",      "=",        D,               "\n",
              "sgnum",    "=",        sgnum,           "\n",
              "res",      "=",        res,             "\n",
              "prefix",   "=",  "\"", calcname, "\"",  "\n",
              # crystal (basis vectors)
              "rvecs",    "=",        rvecs,           "\n",
              # unitcell/lattice shape
              "uc-gvecs", "=",        uc_gvecs,        "\n",
              "uc-coefs", "=",        uc_coefs,        "\n",
              "uc-level", "=",        uc_level,        "\n",
              # permittivities
              "epsin",    "=",        εin,             "\n",
              "epsout",   "=",        εout,            "\n")

    # prepare and write k-vecs and possibly also little group operations
    if lgs !== nothing
        # if `lgs` is supplied, we interpret it as a request to do symmetry eigenvalue
        # calculations at requested little group k-points
        kvecs !== nothing && throw(ArgumentError("One of kvecs or lgs must be nothing"))
        
        # build a unique set of all SymOperations across `lgs` and then find the indices
        # into this set for each lg
        ops = unique(Iterators.flatten(operations.(lgs)))
        idxs2ops = [[findfirst(==(op), ops) for op in operations(lg)] for lg in lgs] 

        # write little group symmetry operations at each k-point (as indexing list of lists)
        write(io, "Ws",     "=");  _vec2list(io, _mat2matrix3x3∘rotation,  ops); println(io)
        write(io, "ws",     "=");  _vec2list(io, _vec2vector3∘translation, ops); println(io)
        write(io, "opidxs", "=");  _vec2list(io, _vec2list, idxs2ops);           println(io)

        # define the k-points across `lgs`, evaluated with (α,β,γ) = (0.25,0.25,0.25)
        αβγ = fill(0.25, D)
        kvecs = map(lg->kvec(lg)(αβγ), lgs)
    end
    write(io, "kvecs",     " ="); _vec2list(io, _vec2vector3, kvecs)

    return nothing
end

function prepare_mpbcalc(sgnum::Integer, flat::AbstractFourierLattice{D}, 
                         Rs::DirectBasis{D}, 
                         filling::Real=0.5, epsin::Real=10.0, epsout::Real=1.0,
                         runtype::String="all";
                         # kwargs
                         id=1, 
                         res::Integer=32, 
                         kvecs::Union{Nothing, AbstractVector{<:Vector{Number}}}=nothing, 
                         lgs::Union{Nothing, AbstractVector{LittleGroup{D}}}=nothing) where D
    io = IOBuffer()
    prepare_mpbcalc!(io, sgnum, flat, Rs, filling, epsin, epsout, runtype; 
                         res=res, id=id, kvecs=kvecs, lgs=lgs)
    return String(take!(io))
end

function gen_symeig_mpbcalc(sgnum, D; res::Integer=32, id=1)
    D ≠ 3 && _throw_1d2d_not_yet_implemented(D)

    brs  = bandreps(sgnum, false, false, "Elementary TR")
    lgs  = matching_lgs(brs)

    cntr = centering(sgnum, D)
    flat = modulate(levelsetlattice(sgnum, D, (1,1,1)))
    Rs   = directbasis(sgnum, D)

    # go to a primitive basis (the lgs from ISOTROPY do not include operations that are 
    # equivalent in a primitive basis, so we _must_ go to the primitive basis)
    lgs′  = primitivize.(lgs)
    flat′ = primitivize(flat, cntr)
    println(length(collect(Iterators.flatten(flat.orbits))))
    println(length(collect(Iterators.flatten(flat′.orbits))))
    Rs′   = primitivize(Rs, cntr)

    prepare_mpbcalc(sgnum, flat′, Rs′; res=res, lgs=lgs, id=id)
end
    


"""
    lattice_from_mpbparams(filepath::String)

This will load an input file with path `filepath` that was previously created 
by `prepare_mpbcalc(!)` and return the associated lattice as Julia objects.

Output:
```
    Rs::DirectBasis, flat::ModulatedFourierLattice, 
    isoval::Float64, epsin::Float64, epsout::Float64
```
Note that `flat` does not retain information about orbit groupings, since we 
flatten the orbits into a single vector in `lattice2mpb`. This doesn't matter
as we typically just want to plot the saved lattice (see `plot_lattice_from_mpbparams`).
"""
function lattice_from_mpbparams(io::IO)
    mark(io) # mark the beginning of stream so we can return to it (otherwise we must assume a fixed order of parameters in input)

    # --- dimension ---
    readuntil(io, "dim=")
    D = parse(Int64, readline(io))

    # --- basis vectors ---
    readuntil(io, "rvecs=")
    if eof(io); reset(io); readuntil(io, "rvecs="); end # try to be robust to arbitrary ordering
    vecs = Tuple(Vector{Float64}(undef, D) for _ in Base.OneTo(D))
    for R in vecs
        readuntil(io, "(vector3 ")
        coords = split.(readuntil(io, ')'))
        R .= parse.(Ref(Float64), coords)
    end
    Rs = DirectBasis{D}(vecs)

    # --- ("flattened") orbits ---
    readuntil(io, "uc-gvecs=")
    if eof(io); reset(io); readuntil(io, "uc-gvecs="); end # try to be robust to arbitrary ordering
    gvecs = Vector{SVector{D, Int64}}() 
    while true
        readuntil(io, "(vector3 ")
        coords = split.(readuntil(io, ')'))
        next_gvec = parse.(Ref(Int64), coords)
        push!(gvecs, next_gvec)
        (read(io, Char) == ')') && break # look for a closing (double) parenthesis to match the assumed opening "(list "
    end

    # --- ("flattened") orbit coefficients --- 
    readuntil(io, "uc-coefs=")
    if eof(io); reset(io); readuntil(io, "uc-coefs="); end # try to be robust to arbitrary ordering
    readuntil(io, "(list ")
    gcoefs = Vector{ComplexF64}(undef, length(gvecs)) 
    for n in eachindex(gcoefs)
        gcoefs[n] = parse(ComplexF64, readuntil(io, x -> isspace(x) || x==')'))
    end

    # --- ("flattened") Fourier Lattice ---
    # note that we've lost info about orbit groupings (since we flatten on exporting 
    # to mpb in lattice2mpb(...)) but it doesn't matter much, as we only ever need
    # to reload these to see the lattice itself.
    flat = ModulatedFourierLattice{D}([gvecs], [gcoefs])

    # --- iso-level ---
    readuntil(io, "uc-level=")
    if eof(io); reset(io); readuntil(io, "uc-level="); end # try to be robust to arbitrary ordering
    isoval = parse(Float64, readline(io))

    # --- epsilon values ---
    readuntil(io, "epsin=")
    if eof(io); reset(io); readuntil(io, "epsin="); end # try to be robust to arbitrary ordering
    epsin = parse(Float64, readline(io))
    readuntil(io, "epsout=")
    if eof(io); reset(io); readuntil(io, "epsout="); end # try to be robust to arbitrary ordering
    epsout = parse(Float64, readline(io))

    unmark(io)
    return Rs, flat, isoval, epsin, epsout
end
lattice_from_mpbparams(filepath::String) = open(filepath) do io; lattice_from_mpbparams(io); end

function plot_lattice_from_mpbparams(filepath::String; kwargs...)
    Rs, flat, isoval, epsin, epsout = lattice_from_mpbparams(filepath)
    plot(flat, Rs; isoval=isoval, kwargs...)
    return nothing
end