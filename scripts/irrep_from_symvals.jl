using Crystalline
import Crystalline: DEFAULT_ATOL, rotation, irdim
using LinearAlgebra, Test, JuMP, GLPK #, Nemo

if !isdefined(Main, :SymmetryBases)
    include((@__DIR__)*"/../src/SymmetryBases/SymmetryBases.jl")
end
using Main.SymmetryBases
const PyNormaliz = Main.SymmetryBases.PyNormaliz

# ------------------------------------------------------------------------------------------

function find_bandrepresentation_lowest_bands(
            sgnum::Integer; 
            timereversal::Bool=true, 
            verbose::Bool=true
            )
    # Irreps at Œì, irrep-multiplicities of œâ=0 2T bands, and symmetry operations
    lgirs = get_lgirreps_at_Œì(sgnum, Val(3))
    timereversal && (lgirs = realify(lgirs))
    lg = group(first(lgirs))
    rotvals = map(op->(W=rotation(op); Crystalline.rotation_order_3d(det(W), tr(W))), lg)

    # 2T irreps; check if "simple treatment"/fast-path is applicable
    ms¬≤·µÄ = find_zero_freq_gamma_transverse_representation(lgirs)
    has_nonmirror_improper = any(‚àà((-1, -3, -4, -6)), rotvals)
    is_regular¬≤·µÄ = all(‚â•(0), ms¬≤·µÄ)
    if !has_nonmirror_improper && is_regular¬≤·µÄ # All symvals known & regular 2T irrep

        # Simple case: if there are no non-mirror improper rotations, we can directly infer 
        # the irrep of the 2T branches. If that irrep is regular (i.e. has no negative
        # coefficients), we don't need to invoke 1L at all, and can solve for just 2T alone.
        msÀ£ = ms¬≤·µÄ
        return find_minimum_bandreps_regular2T(sgnum, lgirs, timereversal, ms¬≤·µÄ; 
                                              safetychecks=true, verbose=verbose)

    else#if !has_nonmirror_improper # All symvals known & irregular 2T and regular 1L irreps
        ms¬π·¥∏ = find_zero_freq_gamma_longitudinal_representation(lgirs)
        ms = find_zero_freq_gamma_representation(lgirs)
        @assert all(ms .== ms¬≤·µÄ .+ ms¬π·¥∏)
        @assert all(‚â•(0), ms¬π·¥∏)                              # check: 1L irrep regular (Œì‚ÇÅ)
        @assert ms == find_zero_freq_gamma_representation(lgirs) # ‚Üí: [2T+1L] = 2T+1L

        return find_minimum_bandreps_regular1L(sgnum, lgirs, timereversal, ms¬π·¥∏, ms;
                                               verbose=verbose)

    #else # Not all symvals known; multiple irrep options
        # TODO: implement non-fast path treatment
        # Main idea is to explore every choice for 1L and 2T that is _feasible_ given the 
        # existing symmetry constraints.
    #    return nothing, nothing, nothing
    end
    #=
    sb, Œìidxs = compatibility_bases_and_Œìidxs(sgnum, lgirs, timereversal)
    ns·¥¥ = matrix(sb)
    maycontain = allowable_ns·¥¥_idxs(msÀ£, ns·¥¥, Œìidxs)
    N·¥¥ = size(ns·¥¥, 2)

    # Try to find a nonnegative expansion in minimal "band-numbers" of basis of `ns·¥¥` 
    # subject to constraints from `ms`; define as a constrained feasibility problem
    m = Model(GLPK.Optimizer)
    @variable(m, c[1:N·¥¥] >= 0, Int)
    @constraint(m, ns·¥¥[Œìidxs,:]*c .>= ms)

    # Define `filling_constraint` as a variable, so its value can be changed on the fly
    @variable(m, filling_constraint)
    @constraint(m, ns·¥¥[end,:]'*c == filling_constraint)
    for filling = 2:MAX_FILL
        # Impose constraints on the number of included bands (band filling)
        fix(filling_constraint, filling) # Change/set `filling_constraint` value
        optimize!(m)

        # Check to see what the termination status (i.e. result) of the optimization was 
        status = termination_status(m)
        if status == MOI.OPTIMAL         # A feasible solution was found
            verbose && println("   Found feasible solution with ŒΩ = ", filling, " bands")
            return m, filling
        end

        # I think this might be doable instead (or optimizable) by just looking at the 
        # individual bases, and excluding those that do not have any elements at _some_ of 
        # the required Œì irreps. Might still need an optimization step though. Wonder if we
        # can try to find all the solutions by excluding a solution once we've found it?
    end
    return m, -1
    =#
end

function find_minimum_bandreps_regular2T(sgnum, lgirs, timereversal, ms¬≤·µÄ; 
                                        verbose::Bool=true, safetychecks::Bool=false)
    verbose && println("SG ", sgnum)

    sb, Œìidxs = compatibility_bases_and_Œìidxs(sgnum, lgirs, timereversal)
    ns·¥¥ = matrix(sb)
    ŒΩs·¥¥ = fillings(sb)
    ŒΩ·¥¥‚Çò‚Çê‚Çì = maximum(ŒΩs·¥¥)
    N·¥¥ = length(sb)

    # We seek an expansion with coefficients c·µ¢‚â•0 such that
    #   P(Œì) ‚àë·µ¢ c·µ¢ ùêß·¥¥·µ¢ ‚â• ùê¶(Œì)
    # where P(Œì) projects out the Œì-irreps from the Hilbert bases ùêß·¥¥·µ¢. In code, this 
    # means we seek a solution with `ns·¥¥[Œìidxs,:]*c ‚â• ms`. Finally, we impose a filling
    # constraint, such that the overall number of bands is at most ŒΩ. In code, this requires
    # that `ns·¥¥[end,:]*c == ŒΩ`. Moreover, all ùêß·¥¥·µ¢ that does not have at least one nonzero
    # entry matching `ms` will not help us in fulfilling these constraints in a nontrivial
    # way, so we can ignore those (would correspond to just stacking on some bands).
    # Finally, we can restrict the sum to contain at most two ùêß·¥¥·µ¢ (same or different): if we
    # have more, then at least one of them isn't actually needed to fulfil ``ùêß(Œì) ‚â• ùê¶(Œì)``,
    # and can then be considered a trivial stacking.

    # the "nontrivial" parts of `n·¥¥` must have at least one positive element for the same 
    # irrep as a nonzero index of `ms`; we can ignore all the others
    ntidxs¬≤·µÄ_ns·¥¥ = find_symmetry_constrained_bases(sb, ms¬≤·µÄ, Œìidxs)

    c‚Å±s = Vector{Int}[]
    ms‚Ä≤ = similar(ms¬≤·µÄ) # buffer
    ŒΩ·µó = 2 # target filling (‚â•2)
    while isempty(c‚Å±s) && ŒΩ·µó ‚â§ 2ŒΩ·¥¥‚Çò‚Çê‚Çì
        for idx·µ¢ in eachindex(ntidxs¬≤·µÄ_ns·¥¥)
            i = ntidxs¬≤·µÄ_ns·¥¥[idx·µ¢]
            # add n·¥¥·µ¢+n·¥¥‚±º to `c‚Å±s` if consistent w/ filling and symmetry constraints
            ŒΩ = test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, (i,), ŒΩ·µó, ms¬≤·µÄ, ŒΩs·¥¥, sb, Œìidxs)
            ŒΩ ‚â• ŒΩ·µó && continue # if ŒΩ already meets or overflows ŒΩ·µó we cannot add more

            # try to add one more Hilbert basis vector, i.e. test n·¥¥·µ¢+n·¥¥‚±º
            for idx‚±º in idx·µ¢:length(ntidxs¬≤·µÄ_ns·¥¥)
                j = ntidxs¬≤·µÄ_ns·¥¥[idx‚±º]
                # add n·¥¥·µ¢+n·¥¥‚±º to `c‚Å±s` if consistent w/ filling and symmetry constraints
                test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, (i,j), ŒΩ·µó, ms¬≤·µÄ, ŒΩs·¥¥, sb, Œìidxs)
            end
        end
        ŒΩ·µó += 1 # increment target filling
    end
    isempty(c‚Å±s) && throw("Found no valid expansions consistent with constraints")
    ŒΩ‚Çò·µ¢‚Çô = ŒΩ·µó - 1

    if safetychecks
        # check that all solutions are valid and unique
        for c‚Å± in c‚Å±s
            isvalid_solution(c‚Å±, sb, ms¬≤·µÄ, ŒΩ‚Çò·µ¢‚Çô, Œìidxs) || throw("Found invalid solution")
        end
        allunique(c‚Å±s) || throw("Found repeated solutions, unexpectedly")
    
        # We can also compare our solutions with a complementary approach:
        c‚Å±s‚Ä≤ = solve_from_linear_diophantine_eqs(ŒΩs·¥¥, ŒΩ‚Çò·µ¢‚Çô, sb, ms¬≤·µÄ, Œìidxs)
        #cs  = idxs2coef.(c‚Å±s, N·¥¥) # convert our solutions to coefficient vectors to compare
        Set(c‚Å±s) ‚â† Set(c‚Å±s‚Ä≤) && throw("Check failed: did not obtain equivalent solutions")
    end       

    # print some stuff, if requested
    verbose && println("   ŒΩ·µÄ = ", ŒΩ‚Çò·µ¢‚Çô, ": ", length(c‚Å±s), " solutions")

    return c‚Å±s, ŒΩ‚Çò·µ¢‚Çô, ns·¥¥
end

function find_minimum_bandreps_regular1L(sgnum, lgirs, timereversal, ms¬π·¥∏, ms;
                    verbose=verbose)
    verbose && println("SG ", sgnum)

    sb, Œìidxs = compatibility_bases_and_Œìidxs(sgnum, lgirs, timereversal)
    ns·¥¥ = matrix(sb)
    N‚Å± ≥ ≥ = size(ns·¥¥, 1)
    notŒìidxs = [idx for idx in 1:N‚Å± ≥ ≥ if idx ‚àâ Œìidxs]
    ŒΩs·¥¥ = fillings(sb)
    ŒΩ·¥¥‚Çò‚Çê‚Çì = maximum(ŒΩs·¥¥)
    ŒΩ·¥¥‚Çò·µ¢‚Çô = minimum(ŒΩs·¥¥)   
    
    # Here, the irrep of 1L is regular (Œì‚ÇÅ) and the irrep of 2T is irregular (i.e. has 
    # negative coefficients). As a result, it is impossible to expand 2T's irrep in the
    # Hilbert basis since it has strictly positive elements and coefficients. We can still
    # can try to find an expansion for 1L+ 2T simultaneously.

    #ntidxs_ns·¥¥   = find_symmetry_constrained_bases(sb, ms,   Œìidxs)
    ntidxs_ns·¥¥   = 1:size(ns·¥¥, 2)
    ntidxs¬π·¥∏_ns·¥¥ = find_symmetry_constrained_bases(sb, ms¬π·¥∏, Œìidxs)
    _, pick = findmin(ŒΩs·¥¥[ntidxs¬π·¥∏_ns·¥¥])
    ntidxs¬π·¥∏_ns·¥¥ = ntidxs¬π·¥∏_ns·¥¥[pick:pick]

    ŒΩs·¥∏ = @view ŒΩs·¥¥[ntidxs¬π·¥∏_ns·¥¥]
    ns·¥∏ = @view sb[ntidxs¬π·¥∏_ns·¥¥]
    ŒΩ·¥∏ = maximum(ŒΩs·¥∏)
    println("   ŒΩ·¥¥‚Çò·µ¢‚Çô = ", ŒΩ·¥¥‚Çò·µ¢‚Çô, ", ŒΩ·¥∏ = ", ŒΩ·¥∏)
    # find _all_ feasible solutions to ms constraints for fixed and minimal ŒΩ·µó; can at 
    # include any number of Hilbert bases in general - we have a fast path for less than 
    # 4 bases, and otherwise fall back to PyNormaliz
    ms‚Ä≤ = similar(ms) # buffer
    idxs·¥∏_keep = Int[]
    ŒΩs·µÄ = Int[]
    ŒΩ·µó = 3 # target filling (‚â•3)
    fargs = (ms, ŒΩs·¥¥, sb, Œìidxs) # fixed args to test_expansion_add_if_valid
    while (isempty(ŒΩs·µÄ) || !(minimum(ŒΩs·µÄ) == 2 || ŒΩ·µó-ŒΩ·¥∏ ‚â• minimum(ŒΩs·µÄ))) && 
           ŒΩ·µó ‚â§ 4*ŒΩ·¥¥‚Çò‚Çê‚Çì

        verbose && print("   ŒΩ·µó = ", ŒΩ·µó, ": ")
        # determine the maximum number of basis terms for an expansion with filling ŒΩ·µó
        max_terms = div(ŒΩ·µó,ŒΩ·¥¥‚Çò·µ¢‚Çô, RoundDown)

        # Determine the solutions to c‚ÇÅŒΩ·¥¥‚ÇÅ + c‚ÇÇŒΩ·¥¥‚ÇÇ + ... = ŒΩ·µó subject to the ms constraint        
        if max_terms ‚â§ 4
            # Fast path by manual looping
            # TODO: Limit number of loops to `max_terms`? Maybe use generated functions...
            c‚Å±s = Vector{Int}[]
            for idx·µ¢ in eachindex(ntidxs_ns·¥¥)
                i = ntidxs_ns·¥¥[idx·µ¢]
                ŒΩ = test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, (i,), ŒΩ·µó, fargs...)
                ŒΩ ‚â• ŒΩ·µó && continue # if ŒΩ already meets or overflows ŒΩ·µó we cannot add more
                for idx‚±º in idx·µ¢:length(ntidxs_ns·¥¥)
                    j = ntidxs_ns·¥¥[idx‚±º]
                    ŒΩ = test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, (i,j), ŒΩ·µó, fargs...)
                    ŒΩ ‚â• ŒΩ·µó && continue
                    for idx‚Çñ in idx‚±º:length(ntidxs_ns·¥¥)
                        k = ntidxs_ns·¥¥[idx‚Çñ]
                        ŒΩ = test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, (i,j,k), ŒΩ·µó, fargs...)
                        ŒΩ ‚â• ŒΩ·µó && continue
                        for idx‚Çó in idx‚Çñ:length(ntidxs_ns·¥¥)
                            l = ntidxs_ns·¥¥[idx‚Çó]
                            test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, (i,j,k,l), ŒΩ·µó, fargs...)
                        end
                    end
                end
            end
            println(length(c‚Å±s), " candidate expansions (from looping)")
        else
            # Fallback to generic solver from Normaliz for higher number of terms
            c‚Å±s = solve_from_linear_diophantine_eqs(ŒΩs·¥¥, ŒΩ·µó, sb, ms, Œìidxs)
            println(length(c‚Å±s), " candidate expansions (from Normaliz)")
        end

        # Proceed to check combinations of c·¥∏ and c
        n = similar(first(sb)) # candidate solution buffer
        for (idx·¥∏, n·¥∏) in enumerate(ns·¥∏) # 1L constraints         
                for c‚Å± in c‚Å±s            # 2T+1L constraints
                    sum_symbases!(n, sb, c‚Å±) # compute new candidate vector from c‚Å± indices
                    # test 1: n(‚àâŒì)-n·¥∏(‚àâŒì) ‚â• 0
                    if all(‚â•(0), @views n[notŒìidxs] .- n·¥∏[notŒìidxs])
                        # test 2: [n(Œì)-n¬π·¥∏‚Å∫¬≤·µÄ‚Çö·µ¢‚Çô(Œì)] - [n·¥∏(Œì)-n¬π·¥∏‚Çö·µ¢‚Çô(Œì)] ‚â• 0
                        if all(‚â•(0), (n[Œìidxs] .- ms) .- (n·¥∏[Œìidxs] .- ms¬π·¥∏)) 
                            n·µÄ = n .- n·¥∏
                            ŒΩ·µÄ = ŒΩ·µó - ŒΩs·¥∏[idx·¥∏]
                            if ŒΩ·µÄ‚àâŒΩs·µÄ
                                push!(ŒΩs·µÄ, ŒΩ·µÄ)
                                println("      Found solution with ŒΩ·µÄ = ", ŒΩ·µÄ)
                            end
                            @goto earlystop
                        end
                    end
                end
            #end
        end
        @label earlystop
        ŒΩ·µó += 1
    end
    
    if !isempty(ŒΩs·µÄ)
        min_ŒΩ·µÄ = minimum((ŒΩs·µÄ))
    else
        throw("   Could not satisfy requirements")
    end

    return nothing, min_ŒΩ·µÄ, nothing
end
# -----------------------------------------------------------------------------------------
"""
    find_symmetry_constrained_bases(sb::SymBasis, ms::AbstractVector{Int},
                                    Œìidxs::AbstractVector{Int})

From a Hilbert basis, specified via `sb::SymBasis` whose elements are the Hilbert basis
vectors, find those that has at least one positive element in overlap with a set irrep 
multiplicities `ms`, whose indices in the rows of the Hilbert basis vectors are specified by
`Œìidxs`.
Returns an array of indices into the the vectors of `sb`.
"""
function find_symmetry_constrained_bases(sb::SymBasis, ms::AbstractVector{Int},
                                         Œìidxs::AbstractVector{Int})
    ntidxs·¥¥ = Int[]
    for (idx, n·¥¥) in enumerate(sb)
        if has_mutual_positive_elements((@view n·¥¥[Œìidxs]), ms)
            push!(ntidxs·¥¥, idx)
        end
    end
    return ntidxs·¥¥
end


# ‚â° any(x>0 & y>0) w/o allocations
has_mutual_positive_elements(x, y) = any(xy -> (xy[1] > 0) & (xy[2] > 0), zip(x,y))

function add_solution!(c‚Å±s::Vector{Vector{Int}}, ijks::NTuple{N, Int}) where N
    # push `ijks` to solution storage `c‚Å±s` as a vector of indices
    push!(c‚Å±s, [idx for idx in ijks])
end

function idxs2coef(c‚Å±, N·¥¥)
    c = zeros(Int, N·¥¥)
    for i in c‚Å±
        c[i] += 1
    end
    return c
end

function coef2idxs(c::AbstractVector{Int})
    N = sum(c)
    c‚Å± = Vector{Int}(undef, N)
    pos‚ÇÅ, pos‚ÇÇ, idx = 0, 0, 0
    while true
        idx  = findnext(‚â†(0), c, idx+1)
        pos‚ÇÅ = pos‚ÇÇ+1
        pos‚ÇÇ = pos‚ÇÇ+c[idx]
        c‚Å±[pos‚ÇÅ:pos‚ÇÇ] .= idx
        pos‚ÇÇ == N && break
    end
    return c‚Å±
end


# we bother to optimize this, as it can be a bottleneck; much faster than a naive 
# implementation like `sum(sb[idxs])`
function sum_symbases!(n, sb::SymBasis, idxs)
    N‚Å± ≥ ≥ = length(n)
    n .= sb[first(idxs)] # peel off 1st iter & ensure invariance to n's inititialization
    @inbounds for idx in @view idxs[2:end]
        n·¥¥ = sb[idx]
        for i in 1:N‚Å± ≥ ≥
            n[i] += n·¥¥[i]
        end
    end
    return n
end
sum_symbases(sb::SymBasis, idxs) = sum_symbases!(similar(first(sb)), sb, idxs)


function test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, # push to c‚Å±s; use ms‚Ä≤ as an updating buffer
                                      ijks::NTuple{N,Int}, ŒΩ·µó, ms, ŒΩs·¥¥, sb, Œìidxs) where N
    if N == 1
        i, = ijks
        ŒΩ = ŒΩs·¥¥[i]                                  # update filling
        ŒΩ ‚â† ŒΩ·µó && return ŒΩ                          # return early if ŒΩ overflows ŒΩ·µó
        @inbounds @views ms‚Ä≤ .= ms .- sb[i][Œìidxs]  # update Œì-constraints
    elseif N == 2
        i,j = ijks
        ŒΩ = ŒΩs·¥¥[i] + ŒΩs·¥¥[j]
        ŒΩ ‚â† ŒΩ·µó && return ŒΩ
        @inbounds @views ms‚Ä≤ .= ms .- sb[i][Œìidxs] .- sb[j][Œìidxs]
    elseif N == 3
        i,j,k = ijks
        ŒΩ = ŒΩs·¥¥[i] + ŒΩs·¥¥[j] + ŒΩs·¥¥[k]
        ŒΩ ‚â† ŒΩ·µó && return ŒΩ
        @inbounds @views ms‚Ä≤ .= ms .- sb[i][Œìidxs] .- sb[j][Œìidxs] .- sb[k][Œìidxs]
    elseif N == 4
        i,j,k,l = ijks
        ŒΩ = ŒΩs·¥¥[i] + ŒΩs·¥¥[j] + ŒΩs·¥¥[k] + ŒΩs·¥¥[l]
        ŒΩ ‚â† ŒΩ·µó && return ŒΩ
        @inbounds @views ms‚Ä≤ .= ms .- sb[i][Œìidxs] .- sb[j][Œìidxs] .- sb[k][Œìidxs] .- sb[l][Œìidxs]
    else
        throw("Unexpected combination of more than three Hilbert bases")
    end

    # check if n·¥¥·µ¢+n·¥¥‚±º+n·¥¥‚Çñ has filling ŒΩ·µó and fulfil symmetry constraints from `ms`
    if all(‚â§(0), ms‚Ä≤) # check if n·¥¥·µ¢+n·¥¥‚±º fulfill `ms` constraints
        add_solution!(c‚Å±s, ijks) # push a solution "i+j" to storage `c‚Å±s`
    end

    return ŒΩ # return filling associated with `ijks` combination
end

# TODO: Complete this and test?
function find_solutions_recursive(c‚Å±s, ms‚Ä≤, idxs, ŒΩ·µó, ms, ŒΩs·¥¥, ns·¥¥, Œìidxs, ntidxs, 
                                  startidx, stopidx, depth, maxdepth)
    if depth == maxdepth
        return nothing
    end
    for idx·µ¢ in startidx:stopidx
        i = ntidxs[idx·µ¢]
        ŒΩ = test_expansion_add_if_valid!(c‚Å±s, ms‚Ä≤, (idxs...,i), ŒΩ·µó, ms, ŒΩs·¥¥, ns·¥¥, Œìidxs)
        if ŒΩ ‚â• ŒΩ·µó 
            continue
        else
            # try to add more Hilbert basis vectors
            find_solutions_recursive(c‚Å±s, ms‚Ä≤, (idxs...,i), ŒΩ·µó, ms, ŒΩs·¥¥, ns·¥¥, Œìidxs, ntidxs,
                                     idx·µ¢, stopidx, depth+1, maxdepth)
        end
    end
    return nothing
end

"""
    solve_from_linear_diophantine_eqs(ŒΩs·¥¥, ŒΩ·µó, ns·¥¥, ms, Œìidxs)

Solves the same problem as `find_minimum_bandreps_regular2T(..)`, but about 20-250√ó slower,
but with a simpler surface implementation.

Returns the coefficient vector `cs` rather than indices into a coefficient vector. The
associated symmetry vector is thus `n = ns·¥¥*c`.
"""
function solve_from_linear_diophantine_eqs(ŒΩs·¥¥, ŒΩ·µó, sb, ms, Œìidxs)
    c‚Å±s = Vector{Int}[]
    #ns·¥¥_Œì = matrix(sb)[Œìidxs,:]
    c‚Å±s_ŒΩ·µó = filling_constrained_ns·¥¥_expansion(ŒΩs·¥¥, ŒΩ·µó, verbose=false)
    n = similar(first(sb))
    for c‚Å± in c‚Å±s_ŒΩ·µó
        sum_symbases!(n, sb, c‚Å±) # set n = ns·¥¥_Œì*c
        if all((@view n[Œìidxs]) .‚â• ms)
            push!(c‚Å±s, c‚Å±)
        end
    end

    return c‚Å±s
end

function compatibility_bases_and_Œìidxs(sgnum, lgirs, timereversal)
    # Find the Hilbert basis that respects the compatibility relations
    sb, _, BRS = compatibility_bases(sgnum, spinful=false, timereversal=timereversal)
    ns·¥¥ = matrix(sb)
    # Find the indices of the Œì irreps in `BRS::BandRepSet` (and hence in `ns·¥¥`), and how  
    # they map to the corresponding irrep indices in `lgirs`
    irlabs_brs = irreplabels(BRS)
    irlabs_lgirs = Crystalline.formatirreplabel.(label.(lgirs))
    Œìidxs = map(irlab->findfirst(==(irlab), irlabs_brs), irlabs_lgirs)

    return sb, Œìidxs
end

function isvalid_solution(idxs::Vector{Int}, sb::SymBasis, ms::Vector{Int}, ŒΩ·µó::Int, Œìidxs)
    n = sum_symbases(sb, idxs)
    return all(n[Œìidxs] .‚â• ms) && n[end] == ŒΩ·µó
end


"""
    filling_constrained_ns·¥¥_expansion(ŒΩs·¥¥::AbstractVector{<:Int}, ŒΩ·µó::Int)

Find all non-negative integer solutions ``{c·µ¢}`` to the linear Diophantine equation

> ``c‚ÇÅŒΩ‚ÇÅ·¥¥ + c‚ÇÇv‚ÇÇ·¥¥ + ... =`` `ŒΩ·µó`

with `ŒΩs·¥¥` ``= [ŒΩ‚ÇÅ·¥¥, ŒΩ‚ÇÇ·¥¥, ...]`` denoting the fillings associated with a Hilbert basis.

Solutions are returned as a `::Vector{Vector{Int}}`. Uses PyNormaliz to solve the integral
polytope defined by the above inhomogeneous equation.

Optionally prints number of solutions, if the kwarg `verbose::Bool=false` is set to `true`.
"""
function filling_constrained_ns·¥¥_expansion(ŒΩs·¥¥::AbstractVector{Int}, ŒΩ·µó::Int;
                                           verbose::Bool=false)

    ŒΩ·µó > 0 || throw(DomainError(ŒΩ·µó, "must be positive"))
    
    # We want to avoid including terms where ŒΩ·µ¢·¥¥ > v·µó since they cannot feature in a valid
    # solution anyway and actually end up slowing down the calculation significantly
    nt_idxs = findall(‚â§(ŒΩ·µó), ŒΩs·¥¥)
    # Specify linear Diophantine equation via PyNormaliz's Cone constructor
    inhom_eqs = reshape([@view ŒΩs·¥¥[nt_idxs]; -ŒΩ·µó], 1, length(nt_idxs)+1)
    #inhom_eqs = reshape([ŒΩs·¥¥; -ŒΩ·µó], 1, length(ŒΩs·¥¥)+1)
    P = PyNormaliz.Cone(inhom_equations = inhom_eqs)
    # Find non-negative integer solutions to the above integral polytope
    normaliz_sols = P.LatticePoints() # distinct solutions across rows

    # last column of `normaliz_sols` is a multiplier on ``-ŒΩ·µó``: should be 1, otherwise it 
    # corresponds to finding a solution that has a filling equal to a multiple of ŒΩ·µó. We 
    # filter out these solutions below.
    #c‚Å±s = [coef2idxs(c‚Ä≤[1:end-1]) for c‚Ä≤ in eachrow(normaliz_sols) if isone(c‚Ä≤[end])]
    c‚Å±s = [nt_idxs[coef2idxs(c‚Ä≤[1:end-1])] for c‚Ä≤ in eachrow(normaliz_sols) if isone(c‚Ä≤[end])]
    
    if verbose 
        println("   ŒΩ·µó = ", ŒΩ·µó, ": ", length(c‚Å±s), " ŒΩ·µó-constrained candidate solutions = ")
        if length(c‚Å±s) ‚â† size(normaliz_sols, 1) 
            println("      DISCARDED \"MULTIPLES\"-SOLUTIONS W/ MULTIPLICITY = ",
                    filter(‚â†(1), unique(normaliz_sols[:,end])))
        end
    end

    return c‚Å±s
end

# ------------------------------------------------------------------------------------------
function get_lgirreps_at_Œì(sgnum::Integer, D·µõ::Val=Val(3)) # small irreps at Œì
   lgirs = first(get_lgirreps(sgnum,  D·µõ))
   kv = kvec(first(lgirs))
   @assert all(iszero, kv.k‚ÇÄ) && isspecial(kv) # Make sure that lgirs indeed is sampled at Œì

   return lgirs
end

function find_zero_freq_gamma_transverse_representation(lgirs::AbstractVector{LGIrrep{3}})
    lg = group(first(lgirs))
    symvals = zero_freq_gamma_transverse_symvals(lg)

    return find_representation(symvals, lgirs, nothing)
end
function find_zero_freq_gamma_longitudinal_representation(lgirs::AbstractVector{LGIrrep{3}})
    lg = group(first(lgirs))
    symvals = zero_freq_gamma_longitudinal_symvals(lg)

    return find_representation(symvals, lgirs, nothing)
end
function find_zero_freq_gamma_representation(lgirs::AbstractVector{LGIrrep{3}})
    lg = group(first(lgirs))
    symvals = zero_freq_gamma_symvals(lg)

    return find_representation(symvals, lgirs)
end
# convenience accessors
for f in (:find_zero_freq_gamma_transverse_representation, 
          :find_zero_freq_gamma_longitudinal_representation,
          :find_zero_freq_gamma_representation)
    @eval function $f(sgnum::Integer; timereversal::Bool=false)
        lgirs = get_lgirreps_at_Œì(sgnum, Val(3))
        timereversal && (lgirs = realify(lgirs))

        return $f(lgirs)
    end
end

# ------------------------------------------------------------------------------------------
# (sum of) symmetry eigenvalues of œâ=0 branches
function zero_freq_gamma_transverse_symvals(ops::AbstractVector{SymOperation{3}})
    symvals·µÄ = Vector{ComplexF64}(undef, length(ops))

    for (i, op) in enumerate(ops)
        W = rotation(op)
        rotval = Crystalline.rotation_order_3d(W)
        
        if rotval != -1     # not inversion
            n = abs(rotval) # rotation order 
            isimproper = signbit(rotval)

            if !isimproper  # ‚Üê "Proper" rotation
                # The symmetry eigenvalues are those of of the 2√ó2 rotation matrix R(Œ∏) ‚â° 
                # [c s; c -s] with c ‚â° cos(Œ∏), s ‚â° sin(Œ∏), and Œ∏ ‚â° 2œÄ/n, i.e. e‚Å∫‚Å±·∂ø and e‚Åª‚Å±·∂ø
                Œ∏ = 2œÄ/n
                symvals·µÄ[i] = 2cos(Œ∏) # e‚Å±·∂ø + e‚Åª‚Å±·∂ø = 2cos(Œ∏)
            else            # ‚Üê Roto-inversion or mirror
                # This is not generally possible to infer for transverse plane waves alone. 
                # E.g., by direct example: there are
                # no lines of symmetry from Œì that contain -4‚ÇÄ‚ÇÄ‚ÇÅ in sg 81; nor any with 
                # -3‚ÇÄ‚ÇÄ‚ÇÅ in sg 147; nor any with -6‚ÇÄ‚ÇÄ‚ÇÅ in sg 174. As such, there is no line 
                # of symmetry from Œì along which transverse plane waves could be 
                # symmetry-allowed eigenfunctions for the rotoinversions

                # It _is_ possible for a simple mirror though (i.e., rotation followed by
                # inversion, i.e. -2 === m): the right choice is to pick the symmetry
                # eigenvalues as +1 and -1 (again, assuming two transverse plane waves along
                # each high-symmetry k-vector)
                if rotval == -2
                    symvals·µÄ[i] = zero(ComplexF64) # (+1) + (-1)
                elseif rotval ‚àà (-3, -4, -6)
                    # SGs with non-mirror rotoinversions 81:88, 111:142, 147:148, 162:167, 
                    # 174:176, 187:194, 200:206, and 215:230
                    Œ∏ = 2œÄ/n
                    symvals·µÄ[i] = -2cos(Œ∏) - 2.0 # [2T+1L] - 1L = [(-e‚Å±·∂ø) + (-e‚Åª‚Å±·∂ø) + (-1)] - (+1)
                else
                    throw("Unexpected rotation value $rotval")
                end
            end
        else                # ‚Üê Inversion
            # This is a bit of a special case because, like rotoinversions, there are no
            # lines of symmetry from Œì that are invariant under inversion. However, if we 
            # recall that, overall, we are considering two transverse and a single
            # longitudinal plane wave branch (‚â°T¬≤+L), which effectively transform like the
            # three Cartesian vectors at Œì, there should be no difficulty since, regardless
            # of partitioning into T¬≤ and L, each symmetry eigenvalue must be -1
            symvals·µÄ[i] = -4.0 # [2T+1L] - 1L = [(-1) + (-1) + (-1)] - (+1)
        end
    end

    return symvals·µÄ
end

function zero_freq_gamma_longitudinal_symvals(ops::AbstractVector{SymOperation{3}})
    symvals·¥∏ = ones(ComplexF64, length(ops)) 
    #=
    Vector{ComplexF64}(undef, length(ops))
    for (i, op) in enumerate(ops)
        W = rotation(op)
        rotval = Crystalline.rotation_order_3d(W)  
        if rotval != -1     # not inversion
            n = abs(rotval) # rotation order 
            isimproper = signbit(rotval)
            if !isimproper  # ‚Üê Ordinary rotation
                symvals·¥∏[i] = one(ComplexF64)
            else            # ‚Üê Roto-inversion or mirror
                if rotval == -2
                    symvals·¥∏[i] = one(ComplexF64)
                elseif rotval ‚àà (-3, -4, -6)
                    symvals·¥∏[i] = ComplexF64(NaN) # Indeterminate
                else
                    throw("Unexpected rotation value $rotval")
                end
            end
        else                # ‚Üê Inversion
            symvals·¥∏[i] = -one(ComplexF64)
        end
    end
    return symvals·¥∏
    =#
end

function zero_freq_gamma_symvals(ops::AbstractVector{SymOperation{3}})
    symvals = Vector{ComplexF64}(undef, length(ops))
    for (i, op) in enumerate(ops)
        W = rotation(op)
        rotval = Crystalline.rotation_order_3d(W)
        n = abs(rotval)
        # This covers every case, including rotations, mirrors, rotoinversions, & inversion
        Œ∏ = 2œÄ/n
        symvals[i] = sign(rotval)* (cis(Œ∏) + cis(-Œ∏) + one(ComplexF64))
    end
    
    return symvals
end
# convenience accessors via space/little groups, ensuring primitive basis
for f in (:zero_freq_gamma_transverse_symvals, :zero_freq_gamma_symvals)
    @eval $f(sg::Union{LittleGroup{3}, SpaceGroup{3}}) = $f(operations(primitivize(sg)))
end

# ------------------------------------------------------------------------------------------

if false
    ŒΩs = getindex.(find_bandrepresentation_lowest_bands.(1:230, timereversal=true, verbose=false),
                   2)

    # Compare with Watanabe & Lu
    Base.ndigits(::Nothing) = 1 # haaaack
    include("scripts/watanabelu_results.jl") # loads Watanabe & Lu data (in `Ms·µÇ·¥∏`)
    Q = [[sg, M, Mbound] for (sg, M, Mbound) ‚àà zip(1:230, ŒΩs, getindex.(Ms·µÇ·¥∏, 2))]
    Q‚Ä≤ = filter(x-> x[2]!==nothing, Q) # filter out those sgs that are not currently implemented (i.e. allow only regular 2T)
    issues = map(x->x[2]===nothing ? "‚îÄ" : (x[2]‚â•(x[3]) ? " " : "!"), Q)
    differences = map(x->x[2]===nothing ? "‚îÄ" : (x[2]==(x[3]) ? " " : "‚â†"), Q)

    foreach(vcat.(Q, issues, differences)) do x
        println("|", " "^(4-ndigits(x[1])), x[1], " |", " "^(3-ndigits(x[2])),  # SG no.
                x[2] === nothing ? "‚îÄ" : x[2], " | ",  # our M predictions
                x[3] == 2 ? "=" : "‚â•", x[3], " | ",    # M-bounds from Watanabe & Lu
                x[4], " | ",                           # bound violations
                x[5], " |"                             # differences from bound?
        )
    end
end